<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Scripts/Actions/MeleeAttackAction.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Scripts/Actions/MeleeAttackAction.cs" />
              <option name="originalContent" value="using SadRogue.Integration;&#10;&#10;namespace Mut8.Scripts.Actions&#10;{&#10;    internal class MeleeAttackAction : AttackAction&#10;    {&#10;        public MeleeAttackAction(RogueLikeEntity sourceEntity, RogueLikeEntity targetEntity) : base(sourceEntity, targetEntity)&#10;        {&#10;            &#10;        }&#10;&#10;        public override ActionResult Perform()&#10;        {&#10;            &#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using Mut8.Scripts.MapObjects.Components;&#10;using SadRogue.Integration;&#10;&#10;namespace Mut8.Scripts.Actions&#10;{&#10;    internal class MeleeAttackAction : AttackAction&#10;    {&#10;        public MeleeAttackAction(RogueLikeEntity sourceEntity, RogueLikeEntity targetEntity) : base(sourceEntity, targetEntity)&#10;        {&#10;        }&#10;&#10;        public override ActionResult Perform()&#10;        {&#10;            var attackerStats = SourceEntity.GetSadComponent&lt;CombatStats&gt;();&#10;            var defenderStats = TargetEntity.GetSadComponent&lt;CombatStats&gt;();&#10;            var defenderHealth = TargetEntity.GetSadComponent&lt;Health&gt;();&#10;&#10;            if (attackerStats == null)&#10;            {&#10;                Engine.MainGame?.MessagePanel?.AddMessage($&quot;{SourceEntity.Name} has no combat stats!&quot;);&#10;                return ActionResult.Failure;&#10;            }&#10;&#10;            if (defenderHealth == null)&#10;            {&#10;                Engine.MainGame?.MessagePanel?.AddMessage($&quot;{TargetEntity.Name} cannot be attacked!&quot;);&#10;                return ActionResult.Failure;&#10;            }&#10;&#10;            // Calculate damage: AttackPower - Defense, with minimum damage&#10;            float defense = defenderStats?.Defense ?? 0f;&#10;            float rawDamage = attackerStats.AttackPower - defense;&#10;            float damage = Math.Max(rawDamage, GameData.MinimumDamage);&#10;&#10;            defenderHealth.TakeDamage(damage);&#10;&#10;            // Log the attack&#10;            string attackMessage = $&quot;{SourceEntity.Name} attacks {TargetEntity.Name} for {damage:F1} damage!&quot;;&#10;            Engine.MainGame?.MessagePanel?.AddMessage(attackMessage);&#10;&#10;            return ActionResult.Success;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Scripts/Core/GameData.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Scripts/Core/GameData.cs" />
              <option name="originalContent" value="namespace Mut8.Scripts&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Contains all game balance constants for tuning gameplay.&#10;    /// &lt;/summary&gt;&#10;    internal static class GameData&#10;    {&#10;        // Health related constants&#10;        public const float BaseMaxHP = 100f;&#10;        public const float StoutGeneHPMultiplier = 20f;&#10;&#10;        // Combat related constants&#10;        public const float BaseAttackPower = 10f;&#10;        public const float BaseDefense = 5f;&#10;        public const float StrongGeneAttackMultiplier = 5f;&#10;        public const float ResilientGeneDefenseMultiplier = 3f;&#10;&#10;        // Gene effectiveness multipliers (for future use)&#10;        public const float QuickGeneSpeedMultiplier = 1f;&#10;        public const float SmartGeneXPMultiplier = 1f;&#10;        public const float StealthyGeneDetectionMultiplier = 1f;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="namespace Mut8.Scripts&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Contains all game balance constants for tuning gameplay.&#10;    /// &lt;/summary&gt;&#10;    internal static class GameData&#10;    {&#10;        // Health related constants&#10;        public const float BaseMaxHP = 100f;&#10;        public const float StoutGeneHPMultiplier = 20f;&#10;&#10;        // Combat related constants&#10;        public const float BaseAttackPower = 10f;&#10;        public const float BaseDefense = 5f;&#10;        public const float StrongGeneAttackMultiplier = 5f;&#10;        public const float ResilientGeneDefenseMultiplier = 3f;&#10;        public const float MinimumDamage = 1f; // Minimum damage dealt even if defense exceeds attack&#10;&#10;        // Gene effectiveness multipliers (for future use)&#10;        public const float QuickGeneSpeedMultiplier = 1f;&#10;        public const float SmartGeneXPMultiplier = 1f;&#10;        public const float StealthyGeneDetectionMultiplier = 1f;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Scripts/GameBalance.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Scripts/GameBalance.cs" />
              <option name="originalContent" value="namespace Mut8.Scripts&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Contains all game balance constants for tuning gameplay.&#10;    /// &lt;/summary&gt;&#10;    internal static class GameBalance&#10;    {&#10;        // Health related constants&#10;        public const int BaseMaxHP = 100;&#10;        public const float StoutGeneHPMultiplier = 20f;&#10;&#10;        // Gene effectiveness multipliers (for future use)&#10;        public const float StrongGeneAttackMultiplier = 1f;&#10;        public const float QuickGeneSpeedMultiplier = 1f;&#10;        public const float ResilientGeneDefenseMultiplier = 1f;&#10;        public const float SmartGeneXPMultiplier = 1f;&#10;        public const float StealthyGeneDetectionMultiplier = 1f;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="namespace Mut8.Scripts&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Contains all game balance constants for tuning gameplay.&#10;    /// &lt;/summary&gt;&#10;    internal static class GameBalance&#10;    {&#10;        // Health related constants&#10;        public const float BaseMaxHP = 100f;&#10;        public const float StoutGeneHPMultiplier = 20f;&#10;&#10;        // Gene effectiveness multipliers (for future use)&#10;        public const float StrongGeneAttackMultiplier = 1f;&#10;        public const float QuickGeneSpeedMultiplier = 1f;&#10;        public const float ResilientGeneDefenseMultiplier = 1f;&#10;        public const float SmartGeneXPMultiplier = 1f;&#10;        public const float StealthyGeneDetectionMultiplier = 1f;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Scripts/MapObjects/Components/CombatStats.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Scripts/MapObjects/Components/CombatStats.cs" />
              <option name="originalContent" value="using Mut8.Scripts.Utils;&#10;using SadRogue.Integration;&#10;using SadRogue.Integration.Components;&#10;&#10;namespace Mut8.Scripts.MapObjects.Components&#10;{&#10;    internal class CombatStats : RogueLikeComponentBase&lt;RogueLikeEntity&gt;&#10;    {&#10;        private Genome? _genome;&#10;&#10;        private float BaseAttackPower { get; set; }&#10;        private float BaseDefense { get; set; }&#10;&#10;        public float AttackPower { get; private set; }&#10;        public float Defense { get; private set; }&#10;&#10;        public event EventHandler? StatsChanged;&#10;&#10;        public CombatStats(float baseAttackPower = 10f, float baseDefense = 5f) : &#10;            base(false, false, false, false)&#10;        {&#10;            BaseAttackPower = baseAttackPower;&#10;            BaseDefense = baseDefense;&#10;            AttackPower = baseAttackPower;&#10;            Defense = baseDefense;&#10;        }&#10;&#10;        public override void OnAdded(IScreenObject parent)&#10;        {&#10;            base.OnAdded(parent);&#10;            _genome = parent.GetSadComponent&lt;Genome&gt;();&#10;&#10;            if (_genome != null)&#10;            {&#10;                _genome.RegisterGeneChangedCallback(Gene.Strong, OnCombatGeneChanged);&#10;                _genome.RegisterGeneChangedCallback(Gene.Resilient, OnCombatGeneChanged);&#10;            }&#10;&#10;            RecalculateStats();&#10;        }&#10;&#10;        public override void OnRemoved(IScreenObject parent)&#10;        {&#10;            if (_genome != null)&#10;            {&#10;                _genome.UnregisterGeneChangedCallback(Gene.Strong, OnCombatGeneChanged);&#10;                _genome.UnregisterGeneChangedCallback(Gene.Resilient, OnCombatGeneChanged);&#10;            }&#10;&#10;            base.OnRemoved(parent);&#10;        }&#10;&#10;        private void OnCombatGeneChanged(float? oldValue, float? newValue)&#10;        {&#10;            RecalculateStats();&#10;        }&#10;&#10;        private void RecalculateStats()&#10;        {&#10;            float strongModifier = _genome?.GetGene(Gene.Strong, 0f) ?? 0f;&#10;            float resilientModifier = _genome?.GetGene(Gene.Resilient, 0f) ?? 0f;&#10;&#10;            float newAttackPower = BaseAttackPower + (GameData.StrongGeneAttackMultiplier * strongModifier);&#10;            float newDefense = BaseDefense + (GameData.ResilientGeneDefenseMultiplier * resilientModifier);&#10;&#10;            if (!newAttackPower.IsEqualWithTolerance(AttackPower) || &#10;                !newDefense.IsEqualWithTolerance(Defense))&#10;            {&#10;                AttackPower = newAttackPower;&#10;                Defense = newDefense;&#10;                StatsChanged?.Invoke(this, EventArgs.Empty);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Mut8.Scripts.Utils;&#10;using SadRogue.Integration;&#10;using SadRogue.Integration.Components;&#10;&#10;namespace Mut8.Scripts.MapObjects.Components&#10;{&#10;    internal class CombatStats : RogueLikeComponentBase&lt;RogueLikeEntity&gt;&#10;    {&#10;        private Genome? _genome;&#10;&#10;        private float BaseAttackPower { get; set; }&#10;        private float BaseDefense { get; set; }&#10;&#10;        public float AttackPower { get; private set; }&#10;        public float Defense { get; private set; }&#10;&#10;        public event EventHandler? StatsChanged;&#10;&#10;        public CombatStats(float baseAttackPower = 10f, float baseDefense = 5f) : &#10;            base(false, false, false, false)&#10;        {&#10;            BaseAttackPower = baseAttackPower;&#10;            BaseDefense = baseDefense;&#10;            AttackPower = baseAttackPower;&#10;            Defense = baseDefense;&#10;        }&#10;&#10;        public override void OnAdded(IScreenObject parent)&#10;        {&#10;            base.OnAdded(parent);&#10;            _genome = parent.GetSadComponent&lt;Genome&gt;();&#10;&#10;            if (_genome != null)&#10;            {&#10;                _genome.RegisterGeneChangedCallback(Gene.Strong, OnCombatGeneChanged);&#10;                _genome.RegisterGeneChangedCallback(Gene.Resilient, OnCombatGeneChanged);&#10;            }&#10;&#10;            RecalculateStats();&#10;        }&#10;&#10;        public override void OnRemoved(IScreenObject parent)&#10;        {&#10;            if (_genome != null)&#10;            {&#10;                _genome.UnregisterGeneChangedCallback(Gene.Strong, OnCombatGeneChanged);&#10;                _genome.UnregisterGeneChangedCallback(Gene.Resilient, OnCombatGeneChanged);&#10;            }&#10;&#10;            base.OnRemoved(parent);&#10;        }&#10;&#10;        private void OnCombatGeneChanged(float oldValue, float newValue)&#10;        {&#10;            RecalculateStats();&#10;        }&#10;&#10;        private void RecalculateStats()&#10;        {&#10;            float strongModifier = _genome?.GetGene(Gene.Strong, 0f) ?? 0f;&#10;            float resilientModifier = _genome?.GetGene(Gene.Resilient, 0f) ?? 0f;&#10;&#10;            float newAttackPower = BaseAttackPower + (GameData.StrongGeneAttackMultiplier * strongModifier);&#10;            float newDefense = BaseDefense + (GameData.ResilientGeneDefenseMultiplier * resilientModifier);&#10;&#10;            if (!newAttackPower.IsEqualWithTolerance(AttackPower) || &#10;                !newDefense.IsEqualWithTolerance(Defense))&#10;            {&#10;                AttackPower = newAttackPower;&#10;                Defense = newDefense;&#10;                StatsChanged?.Invoke(this, EventArgs.Empty);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Scripts/MapObjects/Components/CustomKeybindingsComponent.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Scripts/MapObjects/Components/CustomKeybindingsComponent.cs" />
              <option name="originalContent" value="using System.Collections.ObjectModel;&#10;using GoRogue.GameFramework;&#10;using Mut8.Scripts.Actions;&#10;using SadConsole.Input;&#10;using SadRogue.Integration;&#10;using SadRogue.Integration.Keybindings;&#10;&#10;namespace Mut8.Scripts.MapObjects.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Subclass of the integration library's keybindings component that handles player movement and moves enemies as appropriate when the player&#10;    /// moves.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;remarks&gt;&#10;    /// CUSTOMIZATION: This component is meant to be attached directly to the player entity; if you want to attach it to a renderer, map, or other&#10;    /// surface instead, you'll need to edit the MotionHandler to reference the player directly instead of using the Parent property.  You may also&#10;    /// want to change the parent class type parameter to specify a different type for the parent.&#10;    ///&#10;    /// CUSTOMIZATION: Components can also be attached to maps, so the code for calling TakeTurn on all entities could&#10;    /// be moved to a map component as well so that it is more re-usable by code that doesn't pertain to movement.&#10;    /// &lt;/remarks&gt;&#10;    internal class CustomKeybindingsComponent : KeybindingsComponent&lt;RogueLikeEntity&gt;&#10;    {&#10;        public CustomKeybindingsComponent(uint sortOrder = 5) : base(sortOrder)&#10;        {&#10;            // Bind F3 key to reveal all tiles action&#10;            SetAction(Keys.F3, () =&gt;&#10;            {&#10;                var revealComponent = Parent!.AllComponents.GetFirstOrDefault&lt;RevealAllTilesComponent&gt;();&#10;                revealComponent?.RevealAllTiles();&#10;            });&#10;            &#10;            // Debug keybindings for adding/removing genes&#10;            List&lt;(InputKey, Action)&gt; debugGeneKeybindings = new();&#10;            &#10;            // (Keys.D1, () =&gt;&#10;            // {&#10;            //     var genome = Parent!.AllComponents.GetFirstOrDefault&lt;Genome&gt;();&#10;            //     &#10;            // }),&#10;            // (new InputKey(Keys.D1, KeyModifiers.Shift), () =&gt;&#10;            // {&#10;            //     var genome = Parent!.AllComponents.GetFirstOrDefault&lt;Genome&gt;();&#10;            //     genome.SetGene();&#10;            // })&#10;        }&#10;&#10;        protected override void MotionHandler(Direction direction)&#10;        {&#10;            base.MotionHandler(direction);&#10;&#10;            // Create a walk action&#10;            var walkAction = new MoveAction(Parent!, direction);&#10;&#10;            // Get the Actor component from the parent entity and queue the action&#10;            var actor = Parent!.AllComponents.GetFirstOrDefault&lt;Actor&gt;();&#10;            if (actor != null)&#10;            {&#10;                actor.SetNextAction(walkAction);&#10;            }&#10;&#10;            //if (!Parent!.CanMoveIn(direction)) return;&#10;&#10;                //Parent!.Position += direction;&#10;&#10;                //Engine.MainGame!.MessagePanel.AddMessage(&quot;You move &quot; + direction + &quot;!&quot;);&#10;&#10;                //foreach (var entity in Parent.CurrentMap!.Entities.Items)&#10;                //{&#10;                //    var ai = entity.GoRogueComponents.GetFirstOrDefault&lt;DemoEnemyAI&gt;();&#10;                //    ai?.TakeTurn();&#10;                //}&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.ObjectModel;&#10;using GoRogue.GameFramework;&#10;using Mut8.Scripts.Actions;&#10;using SadConsole.Input;&#10;using SadRogue.Integration;&#10;using SadRogue.Integration.Keybindings;&#10;&#10;namespace Mut8.Scripts.MapObjects.Components&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Subclass of the integration library's keybindings component that handles player movement and moves enemies as appropriate when the player&#10;    /// moves.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;remarks&gt;&#10;    /// CUSTOMIZATION: This component is meant to be attached directly to the player entity; if you want to attach it to a renderer, map, or other&#10;    /// surface instead, you'll need to edit the MotionHandler to reference the player directly instead of using the Parent property.  You may also&#10;    /// want to change the parent class type parameter to specify a different type for the parent.&#10;    ///&#10;    /// CUSTOMIZATION: Components can also be attached to maps, so the code for calling TakeTurn on all entities could&#10;    /// be moved to a map component as well so that it is more re-usable by code that doesn't pertain to movement.&#10;    /// &lt;/remarks&gt;&#10;    internal class CustomKeybindingsComponent : KeybindingsComponent&lt;RogueLikeEntity&gt;&#10;    {&#10;        public CustomKeybindingsComponent(uint sortOrder = 5) : base(sortOrder)&#10;        {&#10;            // Bind F3 key to reveal all tiles action&#10;            SetAction(Keys.F3, () =&gt;&#10;            {&#10;                var revealComponent = Parent!.AllComponents.GetFirstOrDefault&lt;RevealAllTilesComponent&gt;();&#10;                revealComponent?.RevealAllTiles();&#10;            });&#10;            &#10;            // Debug keybindings for adding/removing genes&#10;            var geneValues = Enum.GetValues&lt;Gene&gt;();&#10;            var numberKeys = new[] { Keys.D1, Keys.D2, Keys.D3, Keys.D4, Keys.D5, Keys.D6, Keys.D7, Keys.D8, Keys.D9, Keys.D0 };&#10;            &#10;            for (int i = 0; i &lt; Math.Min(geneValues.Length, numberKeys.Length); i++)&#10;            {&#10;                var gene = geneValues[i];&#10;                var key = numberKeys[i];&#10;                &#10;                // Number key: increment gene&#10;                SetAction(key, () =&gt;&#10;                {&#10;                    var genome = Parent!.AllComponents.GetFirstOrDefault&lt;Genome&gt;();&#10;                    if (genome != null)&#10;                    {&#10;                        var currentValue = genome.GetGene(gene, 0f);&#10;                        genome.SetGene(gene, currentValue + 1f);&#10;                    }&#10;                });&#10;                &#10;                // Shift + Number key: decrement gene&#10;                SetAction(new InputKey(key, KeyModifiers.Shift), () =&gt;&#10;                {&#10;                    var genome = Parent!.AllComponents.GetFirstOrDefault&lt;Genome&gt;();&#10;                    if (genome != null)&#10;                    {&#10;                        var currentValue = genome.GetGene(gene, 0f);&#10;                        var newValue = currentValue - 1f;&#10;                        &#10;                        if (newValue &lt;= 0f)&#10;                        {&#10;                            genome.RemoveGene(gene);&#10;                        }&#10;                        else&#10;                        {&#10;                            genome.SetGene(gene, newValue);&#10;                        }&#10;                    }&#10;                });&#10;            }&#10;        }&#10;&#10;        protected override void MotionHandler(Direction direction)&#10;        {&#10;            base.MotionHandler(direction);&#10;&#10;            // Create a walk action&#10;            var walkAction = new MoveAction(Parent!, direction);&#10;&#10;            // Get the Actor component from the parent entity and queue the action&#10;            var actor = Parent!.AllComponents.GetFirstOrDefault&lt;Actor&gt;();&#10;            if (actor != null)&#10;            {&#10;                actor.SetNextAction(walkAction);&#10;            }&#10;&#10;            //if (!Parent!.CanMoveIn(direction)) return;&#10;&#10;                //Parent!.Position += direction;&#10;&#10;                //Engine.MainGame!.MessagePanel.AddMessage(&quot;You move &quot; + direction + &quot;!&quot;);&#10;&#10;                //foreach (var entity in Parent.CurrentMap!.Entities.Items)&#10;                //{&#10;                //    var ai = entity.GoRogueComponents.GetFirstOrDefault&lt;DemoEnemyAI&gt;();&#10;                //    ai?.TakeTurn();&#10;                //}&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Scripts/MapObjects/Components/Genome.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Scripts/MapObjects/Components/Genome.cs" />
              <option name="originalContent" value="using SadRogue.Integration;&#10;using SadRogue.Integration.Components;&#10;&#10;namespace Mut8.Scripts.MapObjects.Components&#10;{&#10;    public enum Gene&#10;    {&#10;        Strong,&#10;        Quick,&#10;        Resilient,&#10;        Smart,&#10;        Stout,&#10;        Stealthy&#10;    }&#10;&#10;    internal class Genome : RogueLikeComponentBase&lt;RogueLikeEntity&gt;&#10;    {&#10;        private readonly Dictionary&lt;Gene, float&gt; _genes;&#10;        private readonly Dictionary&lt;Gene, List&lt;Action&lt;float?, float?&gt;&gt;&gt; _geneCallbacks;&#10;        &#10;        public IReadOnlyDictionary&lt;Gene, float&gt; Genes =&gt; _genes;&#10;&#10;        public Genome() : base(false, false, false, false)&#10;        {&#10;            _genes = new Dictionary&lt;Gene, float&gt;();&#10;            _geneCallbacks = new Dictionary&lt;Gene, List&lt;Action&lt;float?, float?&gt;&gt;&gt;();&#10;        }&#10;&#10;        public Genome(Dictionary&lt;Gene, float&gt; initialGenes) : base(false, false, false, false)&#10;        {&#10;            _genes = new Dictionary&lt;Gene, float&gt;(initialGenes);&#10;            _geneCallbacks = new Dictionary&lt;Gene, List&lt;Action&lt;float?, float?&gt;&gt;&gt;();&#10;        }&#10;&#10;        public void RegisterGeneChangedCallback(Gene gene, Action&lt;float?, float?&gt; callback)&#10;        {&#10;            if (!_geneCallbacks.ContainsKey(gene))&#10;            {&#10;                _geneCallbacks[gene] = new List&lt;Action&lt;float?, float?&gt;&gt;();&#10;            }&#10;            _geneCallbacks[gene].Add(callback);&#10;        }&#10;&#10;        public void UnregisterGeneChangedCallback(Gene gene, Action&lt;float?, float?&gt; callback)&#10;        {&#10;            if (_geneCallbacks.TryGetValue(gene, out var callbacks))&#10;            {&#10;                callbacks.Remove(callback);&#10;            }&#10;        }&#10;&#10;        public void TriggerGeneChangedCallback(Gene gene, float? oldValue, float? newValue)&#10;        {&#10;            if (_geneCallbacks.TryGetValue(gene, out var callbacks))&#10;            {&#10;                foreach (var callback in callbacks)&#10;                {&#10;                    callback(oldValue, newValue);&#10;                }&#10;            }&#10;        }&#10;&#10;        public float GetGene(Gene gene, float defaultValue = 0f)&#10;        {&#10;            if (_genes.TryGetValue(gene, out var value))&#10;            {&#10;                return value;&#10;            }&#10;            return defaultValue;&#10;        }&#10;&#10;        public void SetGene(Gene gene, float value)&#10;        {&#10;            var oldValue = _genes.TryGetValue(gene, out var existing) ? existing : (float?)null;&#10;            _genes[gene] = value;&#10;            &#10;            TriggerGeneChangedCallback(gene, oldValue, value);&#10;            &#10;            Engine.MainGame?.MessagePanel?.AddMessage($&quot;Gene {gene} changed from {oldValue?.ToString(&quot;F2&quot;) ?? &quot;none&quot;} to {value:F2}.&quot;);&#10;        }&#10;&#10;        public bool HasGene(Gene gene)&#10;        {&#10;            return _genes.ContainsKey(gene);&#10;        }&#10;&#10;        public void RemoveGene(Gene gene)&#10;        {&#10;            if (_genes.TryGetValue(gene, out var oldValue) &amp;&amp; _genes.Remove(gene))&#10;            {&#10;                TriggerGeneChangedCallback(gene, oldValue, null);&#10;            }&#10;        }&#10;&#10;        public Genome Clone()&#10;        {&#10;            return new Genome(new Dictionary&lt;Gene, float&gt;(_genes));&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using SadRogue.Integration;&#10;using SadRogue.Integration.Components;&#10;&#10;namespace Mut8.Scripts.MapObjects.Components&#10;{&#10;    public enum Gene&#10;    {&#10;        Strong,&#10;        Quick,&#10;        Resilient,&#10;        Smart,&#10;        Stout,&#10;        Stealthy&#10;    }&#10;&#10;    internal class Genome : RogueLikeComponentBase&lt;RogueLikeEntity&gt;&#10;    {&#10;        private readonly Dictionary&lt;Gene, float&gt; _genes;&#10;        private readonly Dictionary&lt;Gene, List&lt;Action&lt;float, float&gt;&gt;&gt; _geneCallbacks;&#10;        &#10;        public IReadOnlyDictionary&lt;Gene, float&gt; Genes =&gt; _genes;&#10;&#10;        public Genome() : base(false, false, false, false)&#10;        {&#10;            _genes = new Dictionary&lt;Gene, float&gt;();&#10;            _geneCallbacks = new Dictionary&lt;Gene, List&lt;Action&lt;float, float&gt;&gt;&gt;();&#10;        }&#10;&#10;        public Genome(Dictionary&lt;Gene, float&gt; initialGenes) : base(false, false, false, false)&#10;        {&#10;            _genes = new Dictionary&lt;Gene, float&gt;(initialGenes);&#10;            _geneCallbacks = new Dictionary&lt;Gene, List&lt;Action&lt;float, float&gt;&gt;&gt;();&#10;        }&#10;&#10;        public void RegisterGeneChangedCallback(Gene gene, Action&lt;float, float&gt; callback)&#10;        {&#10;            if (!_geneCallbacks.ContainsKey(gene))&#10;            {&#10;                _geneCallbacks[gene] = new List&lt;Action&lt;float, float&gt;&gt;();&#10;            }&#10;            _geneCallbacks[gene].Add(callback);&#10;        }&#10;&#10;        public void UnregisterGeneChangedCallback(Gene gene, Action&lt;float, float&gt; callback)&#10;        {&#10;            if (_geneCallbacks.TryGetValue(gene, out var callbacks))&#10;            {&#10;                callbacks.Remove(callback);&#10;            }&#10;        }&#10;&#10;        public void TriggerGeneChangedCallback(Gene gene, float oldValue, float newValue)&#10;        {&#10;            if (_geneCallbacks.TryGetValue(gene, out var callbacks))&#10;            {&#10;                foreach (var callback in callbacks)&#10;                {&#10;                    callback(oldValue, newValue);&#10;                }&#10;            }&#10;        }&#10;&#10;        public float GetGene(Gene gene, float defaultValue = 0f)&#10;        {&#10;            if (_genes.TryGetValue(gene, out var value))&#10;            {&#10;                return value;&#10;            }&#10;            return defaultValue;&#10;        }&#10;&#10;        public void SetGene(Gene gene, float value)&#10;        {&#10;            var oldValue = _genes.TryGetValue(gene, out var existing) ? existing : 0f;&#10;            _genes[gene] = value;&#10;            &#10;            TriggerGeneChangedCallback(gene, oldValue, value);&#10;            &#10;            Engine.MainGame?.MessagePanel?.AddMessage($&quot;Gene {gene} changed from {oldValue:F2} to {value:F2}.&quot;);&#10;        }&#10;&#10;        public bool HasGene(Gene gene)&#10;        {&#10;            return _genes.ContainsKey(gene);&#10;        }&#10;&#10;        public void RemoveGene(Gene gene)&#10;        {&#10;            if (_genes.TryGetValue(gene, out var oldValue) &amp;&amp; _genes.Remove(gene))&#10;            {&#10;                TriggerGeneChangedCallback(gene, oldValue, 0f);&#10;            }&#10;        }&#10;&#10;        public Genome Clone()&#10;        {&#10;            return new Genome(new Dictionary&lt;Gene, float&gt;(_genes));&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Scripts/MapObjects/Components/Health.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Scripts/MapObjects/Components/Health.cs" />
              <option name="originalContent" value="using Mut8.Scripts.Utils;&#10;using SadRogue.Integration;&#10;using SadRogue.Integration.Components;&#10;&#10;namespace Mut8.Scripts.MapObjects.Components&#10;{&#10;    internal class Health : RogueLikeComponentBase&lt;RogueLikeEntity&gt;&#10;    {&#10;        private Genome? _genome;&#10;&#10;        private float BaseMaxHP { get; set; }&#10;        &#10;        public float MaxHP { get; private set; }&#10;&#10;        private float _hp;&#10;        public float HP&#10;        {&#10;            get =&gt; _hp;&#10;            private set&#10;            {&#10;                if (_hp == value) return;&#10;&#10;                _hp = Math.Clamp(value, 0f, MaxHP);&#10;                HPChanged?.Invoke(this, EventArgs.Empty);&#10;&#10;                if (_hp &lt;= 0f)&#10;                {&#10;                    Died?.Invoke(this, EventArgs.Empty);&#10;                }&#10;            }&#10;        }&#10;&#10;        public event EventHandler? HPChanged;&#10;        public event EventHandler? Died;&#10;&#10;        public Health(float baseMaxHP = 100f) : base(false, false, false, false)&#10;        {&#10;            BaseMaxHP = baseMaxHP;&#10;            MaxHP = baseMaxHP;&#10;        }&#10;        &#10;        public override void OnAdded(IScreenObject parent)&#10;        {&#10;            base.OnAdded(parent);&#10;            _genome = parent.GetSadComponent&lt;Genome&gt;();&#10;            &#10;            if (_genome != null)&#10;            {&#10;                _genome.RegisterGeneChangedCallback(Gene.Stout, OnStoutGeneChanged);&#10;            }&#10;            &#10;            RecalculateMaxHP();&#10;            HP = MaxHP;&#10;        }&#10;        &#10;        public override void OnRemoved(IScreenObject parent)&#10;        {&#10;            if (_genome != null)&#10;            {&#10;                _genome.UnregisterGeneChangedCallback(Gene.Stout, OnStoutGeneChanged);&#10;            }&#10;            &#10;            base.OnRemoved(parent);&#10;        }&#10;        &#10;        private void OnStoutGeneChanged(float oldValue, float newValue)&#10;        {&#10;            RecalculateMaxHP();&#10;        }&#10;        &#10;        private void RecalculateMaxHP()&#10;        {&#10;            float stoutModifier = _genome?.GetGene(Gene.Stout, 0f) ?? 0f;&#10;            float newMaxHP = BaseMaxHP + (GameData.StoutGeneHPMultiplier * stoutModifier);&#10;            &#10;            if (!newMaxHP.IsEqualWithTolerance(MaxHP))&#10;            {&#10;                float hpRatio = HP / MaxHP;&#10;                MaxHP = newMaxHP;&#10;                HP = Math.Min(HP, MaxHP);&#10;                &#10;                HPChanged?.Invoke(this, EventArgs.Empty);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Mut8.Scripts.Utils;&#10;using SadRogue.Integration;&#10;using SadRogue.Integration.Components;&#10;&#10;namespace Mut8.Scripts.MapObjects.Components&#10;{&#10;    internal class Health : RogueLikeComponentBase&lt;RogueLikeEntity&gt;&#10;    {&#10;        private Genome? _genome;&#10;&#10;        private float BaseMaxHP { get; set; }&#10;        &#10;        public float MaxHP { get; private set; }&#10;&#10;        private float _hp;&#10;        public float HP&#10;        {&#10;            get =&gt; _hp;&#10;            private set&#10;            {&#10;                if (_hp == value) return;&#10;&#10;                _hp = Math.Clamp(value, 0f, MaxHP);&#10;                HPChanged?.Invoke(this, EventArgs.Empty);&#10;&#10;                if (_hp &lt;= 0f)&#10;                {&#10;                    Died?.Invoke(this, EventArgs.Empty);&#10;                }&#10;            }&#10;        }&#10;&#10;        public event EventHandler? HPChanged;&#10;        public event EventHandler? Died;&#10;&#10;        public Health(float baseMaxHP = 100f) : base(false, false, false, false)&#10;        {&#10;            BaseMaxHP = baseMaxHP;&#10;            MaxHP = baseMaxHP;&#10;        }&#10;        &#10;        public override void OnAdded(IScreenObject parent)&#10;        {&#10;            base.OnAdded(parent);&#10;            _genome = parent.GetSadComponent&lt;Genome&gt;();&#10;            &#10;            if (_genome != null)&#10;            {&#10;                _genome.RegisterGeneChangedCallback(Gene.Stout, OnStoutGeneChanged);&#10;            }&#10;            &#10;            RecalculateMaxHP();&#10;            HP = MaxHP;&#10;        }&#10;        &#10;        public override void OnRemoved(IScreenObject parent)&#10;        {&#10;            if (_genome != null)&#10;            {&#10;                _genome.UnregisterGeneChangedCallback(Gene.Stout, OnStoutGeneChanged);&#10;            }&#10;            &#10;            base.OnRemoved(parent);&#10;        }&#10;        &#10;        private void OnStoutGeneChanged(float oldValue, float newValue)&#10;        {&#10;            RecalculateMaxHP();&#10;        }&#10;        &#10;        private void RecalculateMaxHP()&#10;        {&#10;            float stoutModifier = _genome?.GetGene(Gene.Stout, 0f) ?? 0f;&#10;            float newMaxHP = BaseMaxHP + (GameData.StoutGeneHPMultiplier * stoutModifier);&#10;            &#10;            if (!newMaxHP.IsEqualWithTolerance(MaxHP))&#10;            {&#10;                float hpRatio = HP / MaxHP;&#10;                MaxHP = newMaxHP;&#10;                HP = Math.Min(HP, MaxHP);&#10;                &#10;                HPChanged?.Invoke(this, EventArgs.Empty);&#10;            }&#10;        }&#10;&#10;        public void TakeDamage(float damage)&#10;        {&#10;            if (damage &lt; 0f)&#10;            {&#10;                damage = 0f;&#10;            }&#10;&#10;            HP -= damage;&#10;        }&#10;&#10;        public void Heal(float amount)&#10;        {&#10;            if (amount &lt; 0f)&#10;            {&#10;                amount = 0f;&#10;            }&#10;&#10;            HP += amount;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Scripts/Screens/Surfaces/StatusPanel.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Scripts/Screens/Surfaces/StatusPanel.cs" />
              <option name="originalContent" value="&#10;using Mut8.Scripts.MapObjects;&#10;using Mut8.Scripts.MapObjects.Components;&#10;using SadConsole.UI;&#10;using SadConsole.UI.Controls;&#10;&#10;namespace Mut8.Scripts.Screens.Surfaces&#10;{&#10;    internal class StatusPanel : ControlsConsole&#10;    {&#10;        public ProgressBar? HPBar;&#10;        private Player Player;&#10;&#10;        public StatusPanel(int width, int height) : base(width, height)&#10;        {&#10;            CreateHPBar();&#10;        }&#10;&#10;        public void SetPlayer(Player player)&#10;        {&#10;            Player = player;&#10;&#10;            Engine.MainGame!.Player.AllComponents.GetFirst&lt;Health&gt;().HPChanged += OnPlayerHPChanged;&#10;            UpdateHPBar();&#10;        }&#10;&#10;        private void CreateHPBar()&#10;        {&#10;            HPBar = new ProgressBar(Width, 1, HorizontalAlignment.Left)&#10;            {&#10;                DisplayTextColor = Color.White,&#10;                Position = (1, 1)&#10;            };&#10;            Colors hpBarColors = Colors.Default.Clone();&#10;            hpBarColors.Appearance_ControlNormal.Foreground = Color.Green;&#10;            hpBarColors.Appearance_ControlNormal.Background = Color.DarkRed;&#10;            HPBar.SetThemeColors(hpBarColors);&#10;&#10;            Controls.Add(HPBar);&#10;        }&#10;&#10;        private void OnPlayerHPChanged(object? sender, EventArgs e)&#10;        {&#10;            UpdateHPBar();&#10;        }&#10;&#10;        private void UpdateHPBar()&#10;        {&#10;            var health = Engine.MainGame!.Player.AllComponents.GetFirst&lt;Health&gt;();&#10;            HPBar.Progress = health.HP;&#10;            HPBar.DisplayText = $&quot;HP: {health.HP} / {health.MaxHP}&quot;;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using Mut8.Scripts.MapObjects;&#10;using Mut8.Scripts.MapObjects.Components;&#10;using SadConsole.UI;&#10;using SadConsole.UI.Controls;&#10;&#10;namespace Mut8.Scripts.Screens.Surfaces&#10;{&#10;    internal class StatusPanel : ControlsConsole&#10;    {&#10;        public ProgressBar? HPBar;&#10;        private Player Player;&#10;        private readonly Dictionary&lt;Gene, Label&gt; _geneLabels = new();&#10;&#10;        public StatusPanel(int width, int height) : base(width, height)&#10;        {&#10;            CreateHPBar();&#10;            CreateGeneLabels();&#10;        }&#10;&#10;        public void SetPlayer(Player player)&#10;        {&#10;            Player = player;&#10;&#10;            Engine.MainGame!.Player.AllComponents.GetFirst&lt;Health&gt;().HPChanged += OnPlayerHPChanged;&#10;            UpdateHPBar();&#10;&#10;            var genome = Engine.MainGame!.Player.AllComponents.GetFirstOrDefault&lt;Genome&gt;();&#10;            if (genome != null)&#10;            {&#10;                genome.GeneChanged += OnGeneChanged;&#10;                UpdateGeneLabels();&#10;            }&#10;        }&#10;&#10;        private void CreateHPBar()&#10;        {&#10;            HPBar = new ProgressBar(Width, 1, HorizontalAlignment.Left)&#10;            {&#10;                DisplayTextColor = Color.White,&#10;                Position = (1, 1)&#10;            };&#10;            Colors hpBarColors = Colors.Default.Clone();&#10;            hpBarColors.Appearance_ControlNormal.Foreground = Color.Green;&#10;            hpBarColors.Appearance_ControlNormal.Background = Color.DarkRed;&#10;            HPBar.SetThemeColors(hpBarColors);&#10;&#10;            Controls.Add(HPBar);&#10;        }&#10;&#10;        private void CreateGeneLabels()&#10;        {&#10;            var geneValues = Enum.GetValues&lt;Gene&gt;();&#10;            int startY = 3;&#10;&#10;            for (int i = 0; i &lt; geneValues.Length; i++)&#10;            {&#10;                var gene = geneValues[i];&#10;                var label = new Label(Width - 2)&#10;                {&#10;                    Position = (1, startY + i),&#10;                    TextColor = Color.LightGray&#10;                };&#10;                _geneLabels[gene] = label;&#10;                Controls.Add(label);&#10;            }&#10;        }&#10;&#10;        private void OnPlayerHPChanged(object? sender, EventArgs e)&#10;        {&#10;            UpdateHPBar();&#10;        }&#10;&#10;        private void OnGeneChanged(object? sender, GeneChangedEventArgs e)&#10;        {&#10;            UpdateGeneLabels();&#10;        }&#10;&#10;        private void UpdateHPBar()&#10;        {&#10;            var health = Engine.MainGame!.Player.AllComponents.GetFirst&lt;Health&gt;();&#10;            HPBar.Progress = health.HP;&#10;            HPBar.DisplayText = $&quot;HP: {health.HP} / {health.MaxHP}&quot;;&#10;        }&#10;&#10;        private void UpdateGeneLabels()&#10;        {&#10;            var genome = Engine.MainGame!.Player.AllComponents.GetFirstOrDefault&lt;Genome&gt;();&#10;            if (genome == null) return;&#10;&#10;            foreach (var (gene, label) in _geneLabels)&#10;            {&#10;                var value = genome.GetGene(gene, 0f);&#10;                if (value &gt; 0f)&#10;                {&#10;                    label.DisplayText = $&quot;{gene}: {value:F1}&quot;;&#10;                    label.TextColor = Color.Yellow;&#10;                }&#10;                else&#10;                {&#10;                    label.DisplayText = $&quot;{gene}: -&quot;;&#10;                    label.TextColor = Color.DarkGray;&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>